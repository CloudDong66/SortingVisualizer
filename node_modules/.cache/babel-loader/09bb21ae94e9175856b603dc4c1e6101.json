{"ast":null,"code":"export function getHeapSortAnimations(array) {\n  // create animation array \n  const animations = []; // build heap with the input array\n\n  buildMaxHeap(array, animations);\n\n  for (let endIdx = array.length - 1; endIdx > 0; endIdx--) {\n    // 3 pushes for changing color back and forth and swap the comparing values\n    animations.push([0, endIdx]);\n    animations.push([0, endIdx]);\n    animations.push([0, endIdx]); // swap the root(max) with the last node, pop the new last \n    //and heapify down the new root\n\n    swap(0, endIdx, array);\n    heapifyDown(0, endIdx - 1, array, animations);\n  }\n\n  return animations;\n} //build heap\n\nfunction buildMaxHeap(array, animations) {\n  const firstParentIdx = Math.floor((array.length - 2) / 2);\n\n  for (let currentIdx = firstParentIdx; currentIdx >= 0; currentIdx--) {\n    heapifyDown(currentIdx, array.length - 1, array, animations);\n  }\n} // heapify down\n\n\nfunction heapifyDown(currentIdx, endIdx, heap, animations) {\n  let childOneIdx = currentIdx * 2 + 1;\n\n  while (childOneIdx <= endIdx) {\n    // 3 pushes for changing color back and forth and swap the comparing values\n    animations.push([childOneIdx, endIdx]);\n    animations.push([childOneIdx, endIdx]);\n    animations.push([childOneIdx, childOneIdx]);\n    const childTwoIdx = currentIdx * 2 + 2 <= endIdx ? currentIdx * 2 + 2 : -1;\n    let largestIdx;\n\n    if (childTwoIdx !== -1 && heap[childTwoIdx] > heap[childOneIdx]) {\n      largestIdx = childTwoIdx;\n    } else {\n      largestIdx = childOneIdx;\n    }\n\n    if (heap[largestIdx] > heap[currentIdx]) {\n      // 3 pushes for changing color back and forth and swap the comparing values\n      animations.push([currentIdx, largestIdx]);\n      animations.push([currentIdx, largestIdx]);\n      animations.push([currentIdx, largestIdx]);\n      swap(currentIdx, largestIdx, heap);\n      currentIdx = largestIdx;\n      childOneIdx = currentIdx * 2 + 1;\n    } else {\n      return;\n    }\n  }\n}\n\nfunction swap(i, j, array) {\n  let temp = array[j];\n  array[j] = array[i];\n  array[i] = temp;\n}","map":{"version":3,"sources":["/Users/clouddong/Dev/sorting_visualizer/src/sortingAlgorithms/heapSort.js"],"names":["getHeapSortAnimations","array","animations","buildMaxHeap","endIdx","length","push","swap","heapifyDown","firstParentIdx","Math","floor","currentIdx","heap","childOneIdx","childTwoIdx","largestIdx","i","j","temp"],"mappings":"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","sourcesContent":["export function getHeapSortAnimations(array) {\n    // create animation array \n    const animations = []\n    // build heap with the input array\n    buildMaxHeap(array, animations);\n    for (let endIdx = array.length - 1; endIdx > 0; endIdx--) {\n        // 3 pushes for changing color back and forth and swap the comparing values\n        animations.push([0, endIdx]);\n        animations.push([0, endIdx]);\n        animations.push([0, endIdx]);\n        // swap the root(max) with the last node, pop the new last \n        //and heapify down the new root\n        swap(0, endIdx, array);\n        heapifyDown(0, endIdx - 1, array, animations);\n    }\n    return animations;\n}\n\n//build heap\nfunction buildMaxHeap(array, animations) {\n    const firstParentIdx = Math.floor((array.length - 2) / 2);\n    for (let currentIdx = firstParentIdx; currentIdx >= 0; currentIdx--) {\n        heapifyDown(currentIdx, array.length - 1, array, animations);\n    }\n}\n\n// heapify down\nfunction heapifyDown(currentIdx, endIdx, heap, animations) {\n    let childOneIdx = currentIdx * 2 + 1;\n    while(childOneIdx <= endIdx) {\n        // 3 pushes for changing color back and forth and swap the comparing values\n        animations.push([childOneIdx, endIdx]);\n        animations.push([childOneIdx, endIdx]);\n        animations.push([childOneIdx, childOneIdx]);\n        const childTwoIdx = currentIdx * 2 + 2 <= endIdx ? currentIdx * 2 + 2 : -1;\n        let largestIdx;\n        if (childTwoIdx !== -1 && heap[childTwoIdx] > heap[childOneIdx]) {\n            largestIdx = childTwoIdx;\n        } else {\n            largestIdx = childOneIdx;\n        }\n        if (heap[largestIdx] > heap[currentIdx]) {\n            // 3 pushes for changing color back and forth and swap the comparing values\n            animations.push([currentIdx, largestIdx]);\n            animations.push([currentIdx, largestIdx]);\n            animations.push([currentIdx, largestIdx]);\n            swap(currentIdx, largestIdx, heap);\n            currentIdx = largestIdx;\n            childOneIdx = currentIdx * 2 + 1;\n        } else {\n            return;\n        }\n    }\n}\n\nfunction swap(i, j, array) {\n    let temp = array[j];\n    array[j] = array[i];\n    array[i] = temp;\n}"]},"metadata":{},"sourceType":"module"}