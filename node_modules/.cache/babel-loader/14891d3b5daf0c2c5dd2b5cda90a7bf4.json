{"ast":null,"code":"export function getQuickSortAnimations(array) {\n  // create animation arrays\n  const animations = [];\n  quickSortHelper(array, 0, array.length - 1, animations);\n  return animations;\n} //Quick Sort recursive calls \n\nfunction quickSortHelper(array, startIdx, endIdx, animations) {\n  if (startIdx >= endIdx) return; // choose the first index as the pivot\n\n  const pivotIdx = startIdx; // pick left pointer pointing to the index right next to the pivot\n\n  let leftIdx = startIdx + 1; // pick right pointer pointing to the index at the end of the input array\n\n  let rightIdx = endIdx; // check values when the left pointer is not bigger than the right pointer\n\n  while (rightIdx >= leftIdx) {\n    // swap left and right based on quicksort algorithm\n    if (array[leftIdx] > array[pivotIdx] && array[rightIdx] < array[pivotIdx]) {\n      // 3 pushes for changing color back and forth and swap the comparing values \n      animations.push([leftIdx, rightIdx]);\n      animations.push([leftIdx, rightIdx]);\n      animations.push([leftIdx, rightIdx]);\n      swap(leftIdx, rightIdx, array);\n    } // move left pointer to right based on quicksort algorithm\n\n\n    if (array[leftIdx] <= array[pivotIdx]) {\n      // 3 pushes for changing color back and forth and swap the comparing values\n      animations.push([leftIdx, pivotIdx]);\n      animations.push([leftIdx, pivotIdx]);\n      animations.push([rightIdx, rightIdx]);\n      leftIdx++;\n    } // move right pointer to left based on quicksort algorithm\n\n\n    if (array[rightIdx] >= array[pivotIdx]) {\n      // 3 pushes for changing color back and forth and swap the comparing values\n      animations.push([rightIdx, pivotIdx]);\n      animations.push([rightIdx, pivotIdx]);\n      animations.push([rightIdx, rightIdx]);\n      rightIdx--;\n    }\n  } // 3 pushes for changing color back and forth and swap the comparing values\n\n\n  animations.push([pivotIdx, rightIdx]);\n  animations.push([pivotIdx, rightIdx]);\n  animations.push([pivotIdx, rightIdx]); // swap pivot with right pointer\n\n  swap(pivotIdx, rightIdx, array);\n  const leftSubarrayIsSmaller = rightIdx - 1 - startIdx < endIdx - (rightIdx + 1); // recursive call on the smaller subarray to ensure best space complexity\n\n  if (leftSubarrayIsSmaller) {\n    quickSortHelper(array, startIdx, rightIdx - 1, animations);\n    quickSortHelper(array, rightIdx + 1, endIdx, animations);\n  } else {\n    quickSortHelper(array, rightIdx + 1, endIdx, animations);\n    quickSortHelper(array, startIdx, rightIdx - 1, animations);\n  }\n} // swap function\n\n\nfunction swap(i, j, array) {\n  let temp = array[j];\n  array[j] = array[i];\n  array[i] = temp;\n}","map":{"version":3,"sources":["/Users/clouddong/Dev/sorting_visualizer/src/sortingAlgorithms/quickSort.js"],"names":["getQuickSortAnimations","array","animations","quickSortHelper","length","startIdx","endIdx","pivotIdx","leftIdx","rightIdx","push","swap","leftSubarrayIsSmaller","i","j","temp"],"mappings":"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","sourcesContent":["export function getQuickSortAnimations(array) {\n    // create animation arrays\n    const animations = [];\n    quickSortHelper(array, 0, array.length - 1, animations);\n    return animations;\n}\n\n//Quick Sort recursive calls \nfunction quickSortHelper(array, startIdx, endIdx, animations) {\n    if (startIdx >= endIdx) return;\n    // choose the first index as the pivot\n    const pivotIdx = startIdx;\n    // pick left pointer pointing to the index right next to the pivot\n    let leftIdx = startIdx + 1;\n    // pick right pointer pointing to the index at the end of the input array\n    let rightIdx = endIdx;\n\n    // check values when the left pointer is not bigger than the right pointer\n    while (rightIdx >= leftIdx) {\n        // swap left and right based on quicksort algorithm\n        if (array[leftIdx] > array[pivotIdx] && array[rightIdx] < array[pivotIdx]) {\n            // 3 pushes for changing color back and forth and swap the comparing values \n            animations.push([leftIdx, rightIdx]);\n            animations.push([leftIdx, rightIdx]);\n            animations.push([leftIdx, rightIdx]);\n            swap(leftIdx, rightIdx, array);\n        }\n        // move left pointer to right based on quicksort algorithm\n        if (array[leftIdx] <= array[pivotIdx]) {\n            // 3 pushes for changing color back and forth and swap the comparing values\n            animations.push([leftIdx, pivotIdx]);\n            animations.push([leftIdx, pivotIdx]);\n            animations.push([rightIdx, rightIdx]);\n            leftIdx++;\n        }\n        // move right pointer to left based on quicksort algorithm\n        if (array[rightIdx] >= array[pivotIdx]) {\n            // 3 pushes for changing color back and forth and swap the comparing values\n            animations.push([rightIdx, pivotIdx]);\n            animations.push([rightIdx, pivotIdx]);\n            animations.push([rightIdx, rightIdx]);\n            rightIdx--;\n        }\n    }\n\n    // 3 pushes for changing color back and forth and swap the comparing values\n    animations.push([pivotIdx, rightIdx]);\n    animations.push([pivotIdx, rightIdx]);\n    animations.push([pivotIdx, rightIdx]);\n    // swap pivot with right pointer\n    swap(pivotIdx, rightIdx, array);\n    const leftSubarrayIsSmaller = rightIdx - 1 - startIdx < endIdx - (rightIdx + 1);\n    // recursive call on the smaller subarray to ensure best space complexity\n    if (leftSubarrayIsSmaller) {\n        quickSortHelper(array, startIdx, rightIdx - 1, animations);\n        quickSortHelper(array, rightIdx + 1, endIdx, animations);\n    } else {\n        quickSortHelper(array, rightIdx + 1, endIdx, animations);\n        quickSortHelper(array, startIdx, rightIdx - 1, animations);\n    }\n}\n\n// swap function\nfunction swap(i, j, array) {\n    let temp = array[j];\n    array[j] = array[i];\n    array[i] = temp;\n}"]},"metadata":{},"sourceType":"module"}